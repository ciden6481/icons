name: Auto README Generator

on:
  push:
    branches:
      - '**'
  workflow_dispatch:

jobs:
  generate-readme:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Generate README files
        shell: bash
        run: |
          set -e
          
          # Configuration
          EXCLUDED_FOLDERS=".git,.github,node_modules"
          EXCLUDED_PATTERNS=".gitignore,.DS_Store"
          
          # Function to check if folder should be excluded
          should_exclude_folder() {
            local folder="$1"
            IFS=',' read -ra EXCLUDED <<< "$EXCLUDED_FOLDERS"
            for exclude in "${EXCLUDED[@]}"; do
              if [[ "$folder" == "$exclude"* ]] || [[ "$folder" == *"/$exclude"* ]]; then
                return 0
              fi
            done
            return 1
          }
          
          # Function to check if file should be excluded
          should_exclude_file() {
            local file="$1"
            local filename=$(basename "$file")
            IFS=',' read -ra PATTERNS <<< "$EXCLUDED_PATTERNS"
            for pattern in "${PATTERNS[@]}"; do
              if [[ "$filename" == $pattern ]]; then
                return 0
              fi
            done
            return 1
          }
          
          # Function to format file size
          format_size() {
            local bytes=$1
            if (( bytes < 1024 )); then
              echo "${bytes}B"
            elif (( bytes < 1048576 )); then
              echo "$(( bytes / 1024 ))KB"
            else
              echo "$(( bytes / 1048576 ))MB"
            fi
          }
          
          # Function to extract description from TOC file
          extract_description() {
            local toc_file="$1"
            if [[ -f "$toc_file" ]]; then
              # Extract text after "**Description:**" on the same line or next line
              local desc=$(sed -n 's/\*\*Description:\*\*[[:space:]]*//p' "$toc_file" | head -1)
              if [[ -z "$desc" ]]; then
                # Try to get description from next line after "**Description:**"
                desc=$(sed -n '/\*\*Description:\*\*/{ n; p; }' "$toc_file" | head -1 | sed 's/^[[:space:]]*//')
              fi
              # Clean up empty brackets or placeholder text
              desc=$(echo "$desc" | sed 's/\[Add description here\]//; s/^[[:space:]]*$//; s/^[[:space:]]*//; s/[[:space:]]*$//')
              echo "$desc"
            fi
          }
          
          # Function to get display name for file extension
          get_extension_name() {
            local ext="$1"
            case "$ext" in
              md) echo "Markdown Files" ;;
              svg) echo "SVG Files" ;;
              png) echo "PNG Files" ;;
              jpg|jpeg) echo "JPEG Files" ;;
              gif) echo "GIF Files" ;;
              txt) echo "Text Files" ;;
              json) echo "JSON Files" ;;
              yml|yaml) echo "YAML Files" ;;
              xml) echo "XML Files" ;;
              pdf) echo "PDF Files" ;;
              no-extension) echo "Files (no extension)" ;;
              *) echo "${ext^^} Files" ;;
            esac
          }
          
          # Function to get emoji for file type
          get_file_emoji() {
            local ext="$1"
            case "$ext" in
              md) echo "üìù" ;;
              svg) echo "üé®" ;;
              png|jpg|jpeg|gif) echo "üñºÔ∏è" ;;
              txt) echo "üìÑ" ;;
              json|yml|yaml|xml) echo "‚öôÔ∏è" ;;
              pdf) echo "üìï" ;;
              no-extension) echo "üìé" ;;
              *) echo "üìÑ" ;;
            esac
          }
          
          # Get repository info
          REPO_OWNER="${GITHUB_REPOSITORY%/*}"
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          BRANCH="${GITHUB_REF#refs/heads/}"
          
          # Function to process a single folder
          process_folder() {
            local folder="$1"
            
            # Get folder name for title
            if [[ "$folder" == "." ]]; then
              folder_name="$(basename "$(pwd)")"
            else
              folder_name="$(basename "$folder")"
            fi
            
            local toc_filename="${folder_name}-TOC.md"
            local toc_path="$folder/$toc_filename"
            
            # For root folder, place TOC file in root
            if [[ "$folder" == "." ]]; then
              toc_path="$toc_filename"
            fi
            
            echo "Processing folder: $folder"
            
            # If TOC file doesn't exist, create it with template
            if [[ ! -f "$toc_path" ]]; then
              echo "# $folder_name" > "$toc_path"
              echo "" >> "$toc_path"
              echo "**Description:** [Add description here]" >> "$toc_path"
              echo "" >> "$toc_path"
              echo "---" >> "$toc_path"
              echo "" >> "$toc_path"
              echo "<!-- Auto-generated content below. Do not edit between markers. -->" >> "$toc_path"
              echo "<!-- BEGIN AUTO-GENERATED CONTENT -->" >> "$toc_path"
              echo "<!-- END AUTO-GENERATED CONTENT -->" >> "$toc_path"
            fi
            
            # Extract manual content before marker and generate new file
            echo "DEBUG: Starting TOC generation for $toc_path" >&2
            {
              echo "DEBUG: Extracting header" >&2
              # Extract header content (everything up to and including the BEGIN marker)
              if sed -n '1,/<!-- BEGIN AUTO-GENERATED CONTENT -->/p' "$toc_path" 2>/dev/null | grep -q .; then
                sed -n '1,/<!-- BEGIN AUTO-GENERATED CONTENT -->/p' "$toc_path"
              else
                # Fallback if sed fails or produces no output - write minimal header
                echo "# $folder_name"
                echo ""
                echo "**Description:**"
                echo ""
                echo "---"
                echo ""
                echo "<!-- Auto-generated content below. Do not edit between markers. -->"
                echo "<!-- BEGIN AUTO-GENERATED CONTENT -->"
              fi
              
              echo "DEBUG: Finding subfolders" >&2
              # Find subfolders
              local subfolders=()
              while IFS= read -r -d '' subfolder; do
                local rel_subfolder="${subfolder#./}"
                if should_exclude_folder "$rel_subfolder"; then
                  continue
                fi
                subfolders+=("$rel_subfolder")
              done < <(find "$folder" -mindepth 1 -maxdepth 1 -type d -print0 | sort -z)
              
              echo "DEBUG: Found ${#subfolders[@]} subfolders" >&2
              # Generate subfolders table
              if [[ ${#subfolders[@]} -gt 0 ]]; then
                echo "DEBUG: Generating subfolders table" >&2
                echo "### üìÅ Subfolders"
                echo ""
                echo "| Folder | Description | Files | Folders |"
                echo "|--------|-------------|-------|--------|"
                
                for subfolder in "${subfolders[@]}"; do
                  local subfolder_name=$(basename "$subfolder")
                  local subfolder_toc="$subfolder/${subfolder_name}-TOC.md"
                  local description=$(extract_description "$subfolder_toc")
                  
                  # Count files (excluding TOC and hidden files)
                  local file_count=0
                  while IFS= read -r -d '' file; do
                    local filename=$(basename "$file")
                    if [[ "$filename" != "${subfolder_name}-TOC.md" ]] && ! should_exclude_file "$file"; then
                      ((file_count++))
                    fi
                  done < <(find "$subfolder" -maxdepth 1 -type f -print0 2>/dev/null)
                  
                  # Count subfolders (excluding hidden and excluded)
                  local folder_count=0
                  while IFS= read -r -d '' child_folder; do
                    local child_rel="${child_folder#./}"
                    if ! should_exclude_folder "$child_rel"; then
                      ((folder_count++))
                    fi
                  done < <(find "$subfolder" -mindepth 1 -maxdepth 1 -type d -print0 2>/dev/null)
                  
                  # Relative path for link
                  local relative_path="${subfolder#$folder/}"
                  if [[ "$folder" == "." ]]; then
                    relative_path="$subfolder"
                  fi
                  
                  echo "| [$subfolder_name]($relative_path/${subfolder_name}-TOC.md) | $description | $file_count | $folder_count |"
                done
                
                echo ""
              fi
              
              echo "DEBUG: Finding and grouping files" >&2
              # Find files and group by extension
              declare -A files_by_ext
              while IFS= read -r -d '' file; do
                local filename=$(basename "$file")
                
                # Skip TOC file and excluded files
                if [[ "$file" == "$toc_path" ]] || should_exclude_file "$file"; then
                  continue
                fi
                
                # Get extension
                local ext="${filename##*.}"
                if [[ "$filename" == "$ext" ]]; then
                  ext="no-extension"
                fi
                
                # Add to group
                if [[ -z "${files_by_ext[$ext]}" ]]; then
                  files_by_ext[$ext]="$file"
                else
                  files_by_ext[$ext]+=$'\n'"$file"
                fi
              done < <(find "$folder" -maxdepth 1 -type f -print0 | sort -z)
              
              echo "DEBUG: Found ${#files_by_ext[@]} file groups" >&2
              # Generate file tables by extension
              for ext in $(echo "${!files_by_ext[@]}" | tr ' ' '\n' | sort); do
                echo "DEBUG: Processing extension group: $ext" >&2
                local ext_name=$(get_extension_name "$ext")
                local emoji=$(get_file_emoji "$ext")
                
                echo "### $emoji $ext_name"
                echo ""
                echo "| Filename | Type | Size | View | Raw |"
                echo "|----------|------|------|------|-----|"
                
                # Sort files in this group
                while IFS= read -r file; do
                  [[ -z "$file" ]] && continue
                  
                  local filename=$(basename "$file")
                  local size=$(stat -c%s "$file" 2>/dev/null || stat -f%z "$file" 2>/dev/null)
                  local formatted_size=$(format_size $size)
                  
                  # Generate URLs
                  local relative_path="${file#./}"
                  local encoded_path=$(echo "$relative_path" | sed 's/ /%20/g')
                  local view_url="https://github.com/$REPO_OWNER/$REPO_NAME/blob/$BRANCH/$encoded_path"
                  local raw_url="https://raw.githubusercontent.com/$REPO_OWNER/$REPO_NAME/$BRANCH/$encoded_path"
                  
                  echo "| \`$filename\` | .$ext | $formatted_size | [View]($view_url) | [Raw]($raw_url) |"
                done <<< "$(echo "${files_by_ext[$ext]}" | sort)"
                
                echo ""
              done
              
              echo "DEBUG: Extracting footer" >&2
              # Extract manual content after marker (footer)
              if sed -n '/<!-- END AUTO-GENERATED CONTENT -->/,$p' "$toc_path" 2>/dev/null | grep -q .; then
                sed -n '/<!-- END AUTO-GENERATED CONTENT -->/,$p' "$toc_path"
              else
                # Fallback if sed fails or produces no output - write closing marker
                echo "<!-- END AUTO-GENERATED CONTENT -->"
              fi
            } > "$toc_path.tmp"
            
            echo "DEBUG: TOC generation complete, checking temp file" >&2
            # Verify temp file was created and has content before moving
            if [[ -s "$toc_path.tmp" ]]; then
              echo "DEBUG: Moving temp file to $toc_path" >&2
              mv "$toc_path.tmp" "$toc_path"
            else
              echo "Error: Failed to generate content for $toc_path" >&2
              rm -f "$toc_path.tmp"
              return 1
            fi
          }
          
          # Find all folders recursively and process them
          echo "Finding all folders..."
          
          # Process root folder first
          echo "Processing root folder..."
          process_folder "."
          
          # Process all subfolders
          while IFS= read -r -d '' folder; do
            rel_folder="${folder#./}"
            if should_exclude_folder "$rel_folder"; then
              echo "Skipping excluded folder: $rel_folder"
              continue
            fi
            
            echo "Processing subfolder: $rel_folder"
            process_folder "$folder"
          done < <(find . -mindepth 1 -type d -print0 | sort -z)
          
          echo "README generation complete!"
      
      - name: Commit changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: 'docs: auto-update TOC files [skip ci]'
          file_pattern: '**/*-TOC.md'
          commit_user_name: 'github-actions[bot]'
          commit_user_email: 'github-actions[bot]@users.noreply.github.com'
